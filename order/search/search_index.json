{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A module loader framework for Roblox that provides simple and fast module lookup, cyclic dependency support, a customizable initialization sequence, and more! Created by @ChiefWildin What's so special about Order? The core design principle in Order is to remove barriers and enable the developer . It combines the best features of current popular frameworks, and adds a few of its own. Are there any unique features in Order? There are! One of these unique features is the ability to have modules with circular dependencies. Occasionally, libaries and tasks need to interchangably use one another's public functions and variables, but Luau doesn't allow this by default. Order achieves support for this through a metatable-based bait-and-switch style tactic (see Special notes ). Is there anything else I need to know? Order is a relatively new framework, and I'm still actively developing it. As such, functionality and features can and will change at any time and I'm still ironing out all the kinks and bugs. If you have any suggestions or find any bugs yourself, feel free to reach out! Issues, discussions, and pull requests can be submitted to the project repo , or you can join the [ nxt_lvl ] Discord server !","title":"Home"},{"location":"#_1","text":"A module loader framework for Roblox that provides simple and fast module lookup, cyclic dependency support, a customizable initialization sequence, and more! Created by @ChiefWildin","title":""},{"location":"#whats-so-special-about-order","text":"The core design principle in Order is to remove barriers and enable the developer . It combines the best features of current popular frameworks, and adds a few of its own.","title":"What's so special about Order?"},{"location":"#are-there-any-unique-features-in-order","text":"There are! One of these unique features is the ability to have modules with circular dependencies. Occasionally, libaries and tasks need to interchangably use one another's public functions and variables, but Luau doesn't allow this by default. Order achieves support for this through a metatable-based bait-and-switch style tactic (see Special notes ).","title":"Are there any unique features in Order?"},{"location":"#is-there-anything-else-i-need-to-know","text":"Order is a relatively new framework, and I'm still actively developing it. As such, functionality and features can and will change at any time and I'm still ironing out all the kinks and bugs. If you have any suggestions or find any bugs yourself, feel free to reach out! Issues, discussions, and pull requests can be submitted to the project repo , or you can join the [ nxt_lvl ] Discord server !","title":"Is there anything else I need to know?"},{"location":"api/","text":"API Settings The framework settings module (located at src/_order/Settings.lua ) has a few different options that developers can customize for their projects. DebugMode - When set to true this will make the loading process verbose so that you can iterate on the framework or tweak behavior. SilentMode - When set to true this will disable all regular output (version printing, notifications about when initialization has finished, etc.) This will not disable warnings. By default this is turned off during Studio development, and turned on for production. InitOrder - Can be set to either \"Project\" or \"Individual\" . Project means that each initialization function will be run on every task before moving on to the next initialization function. Individual means that each task will run through each of its initialization functions before moving on to the next task. Both settings respect module priority values. InitFunctionConfig - A table that defines the initialization functions for the project and their options. PortableMode - An experimental setting that allows Order to run in a portable mode where it does not assume it is the main or only framework in the game. This is intended for use with plugins or other small scope projects and will require a custom project structure. File structure Tasks Tasks are modules that have code intended for immediate execution at runtime. Tasks should be placed in the tasks folder of the appropriate context. Info Any module that is placed inside the tasks folder will be loaded by default, even if no initialization function exists within it or if it isn't even a table. All other modules are loaded only as requested. Priorities If you wish to give a task priority during the initialization phase, set a Priority key in the main module table to the priority level you would like (higher values load first, negative values load last). Setting a priority is optional - if you don't set one, the task will be set to priority 0 by default. Warning Tasks with priorities are still initialized asynchronously, so if the task yields during initialization there is no guarantee that it will finish before a lower priority task starts initializing. Tasks with the same priority are initialized in an arbitrary order. Initialization functions and synchronization In the default configuration, tasks can place their code to execute into two initialization functions: :Prep() and :Init() . :Prep() comes first and is synchronous, and then :Init() comes after and is asynchronous. Tasks are not required to have either, and are allowed to define their own initialization functions if desired. These can be defined by placing a table called InitConfigOverride in the module table, following the same structure as is found for InitFunctionConfig in the Settings.lua file of the framework folder. Example local NewTask = { Priority = 5 , } function NewTask : Prep () print ( \"Task is prepped.\" ) end s function NewTask : Init () print ( \"Task is running!\" ) end return NewTask Everything else All other modules can be placed in the provided lib folder, or any other custom folders that you create. File paths There are five top-level directories by default: character - StarterPlayer.StarterCharacterScripts client - StarterPlayer.StarterPlayerScripts first - ReplicatedFirst server - ServerScriptService shared - ReplicatedStorage.Shared Note first and character are not scanned for task modules, as it is assumed that developers will simply use LocalScripts/Scripts instead. If you wish to add tasks there, you may add custom support at the end of the main framework module. For Rojo users, further file path customization can be configured in the default.project.json file. Loading dependencies Order makes use of the shared global variable to load dependencies. In code, this takes the place of the usual require keyword. This function can take either a string of the module's name, a string of a partial or complete path to the module, or a direct object reference to a ModuleScript. Valid examples: local AnimNation = shared ( \"AnimNation\" ) local AnimNation = shared ( \"lib/AnimNation\" ) local AnimNation = shared ( game : GetService ( \"ReplicatedStorage\" ). Shared . lib . AnimNation ) Warning When two or more modules exist with the same name or partial path, Order will warn you that it found multiple modules for your request, and will ask you to be more specific. You can use any level of the module paths it provides you with, as long as it is unique. The Order module itself can also be used instead of shared if you have other uses for that keyword, want to avoid globals like the plague, or are running in portable mode. For example: local require = require ( game : GetService ( \"ReplicatedStorage\" ). Shared . Order ) Supporting modules from other frameworks If you would like to import a module from another framework that uses require to load dependencies (such as Nevermore), simply redirect require to shared : local require = shared Or, alternatively, you can redirect their require call to the main Order module: local require = require ( game : GetService ( \"ReplicatedStorage\" ). Shared . Order ) Also be sure to update your initializer configuration to support the module's intended initialization procedure (or adapt it to Order's, if preferred.)","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#settings","text":"The framework settings module (located at src/_order/Settings.lua ) has a few different options that developers can customize for their projects. DebugMode - When set to true this will make the loading process verbose so that you can iterate on the framework or tweak behavior. SilentMode - When set to true this will disable all regular output (version printing, notifications about when initialization has finished, etc.) This will not disable warnings. By default this is turned off during Studio development, and turned on for production. InitOrder - Can be set to either \"Project\" or \"Individual\" . Project means that each initialization function will be run on every task before moving on to the next initialization function. Individual means that each task will run through each of its initialization functions before moving on to the next task. Both settings respect module priority values. InitFunctionConfig - A table that defines the initialization functions for the project and their options. PortableMode - An experimental setting that allows Order to run in a portable mode where it does not assume it is the main or only framework in the game. This is intended for use with plugins or other small scope projects and will require a custom project structure.","title":"Settings"},{"location":"api/#file-structure","text":"","title":"File structure"},{"location":"api/#tasks","text":"Tasks are modules that have code intended for immediate execution at runtime. Tasks should be placed in the tasks folder of the appropriate context. Info Any module that is placed inside the tasks folder will be loaded by default, even if no initialization function exists within it or if it isn't even a table. All other modules are loaded only as requested.","title":"Tasks"},{"location":"api/#priorities","text":"If you wish to give a task priority during the initialization phase, set a Priority key in the main module table to the priority level you would like (higher values load first, negative values load last). Setting a priority is optional - if you don't set one, the task will be set to priority 0 by default. Warning Tasks with priorities are still initialized asynchronously, so if the task yields during initialization there is no guarantee that it will finish before a lower priority task starts initializing. Tasks with the same priority are initialized in an arbitrary order.","title":"Priorities"},{"location":"api/#initialization-functions-and-synchronization","text":"In the default configuration, tasks can place their code to execute into two initialization functions: :Prep() and :Init() . :Prep() comes first and is synchronous, and then :Init() comes after and is asynchronous. Tasks are not required to have either, and are allowed to define their own initialization functions if desired. These can be defined by placing a table called InitConfigOverride in the module table, following the same structure as is found for InitFunctionConfig in the Settings.lua file of the framework folder.","title":"Initialization functions and synchronization"},{"location":"api/#example","text":"local NewTask = { Priority = 5 , } function NewTask : Prep () print ( \"Task is prepped.\" ) end s function NewTask : Init () print ( \"Task is running!\" ) end return NewTask","title":"Example"},{"location":"api/#everything-else","text":"All other modules can be placed in the provided lib folder, or any other custom folders that you create.","title":"Everything else"},{"location":"api/#file-paths","text":"There are five top-level directories by default: character - StarterPlayer.StarterCharacterScripts client - StarterPlayer.StarterPlayerScripts first - ReplicatedFirst server - ServerScriptService shared - ReplicatedStorage.Shared Note first and character are not scanned for task modules, as it is assumed that developers will simply use LocalScripts/Scripts instead. If you wish to add tasks there, you may add custom support at the end of the main framework module. For Rojo users, further file path customization can be configured in the default.project.json file.","title":"File paths"},{"location":"api/#loading-dependencies","text":"Order makes use of the shared global variable to load dependencies. In code, this takes the place of the usual require keyword. This function can take either a string of the module's name, a string of a partial or complete path to the module, or a direct object reference to a ModuleScript. Valid examples: local AnimNation = shared ( \"AnimNation\" ) local AnimNation = shared ( \"lib/AnimNation\" ) local AnimNation = shared ( game : GetService ( \"ReplicatedStorage\" ). Shared . lib . AnimNation ) Warning When two or more modules exist with the same name or partial path, Order will warn you that it found multiple modules for your request, and will ask you to be more specific. You can use any level of the module paths it provides you with, as long as it is unique. The Order module itself can also be used instead of shared if you have other uses for that keyword, want to avoid globals like the plague, or are running in portable mode. For example: local require = require ( game : GetService ( \"ReplicatedStorage\" ). Shared . Order )","title":"Loading dependencies"},{"location":"api/#supporting-modules-from-other-frameworks","text":"If you would like to import a module from another framework that uses require to load dependencies (such as Nevermore), simply redirect require to shared : local require = shared Or, alternatively, you can redirect their require call to the main Order module: local require = require ( game : GetService ( \"ReplicatedStorage\" ). Shared . Order ) Also be sure to update your initializer configuration to support the module's intended initialization procedure (or adapt it to Order's, if preferred.)","title":"Supporting modules from other frameworks"},{"location":"contributions/","text":"Want to make a contribution? Order is a fully open-source project, and I would love to take community contributions that will make it even better! In the interest of quality control though, I've decided to set forth some rules that contributions must follow in order to be integrated into the project. If this all sounds good to you, make a pull request ! Rules Style - Contributions should do their best to conform to the Roblox Luau Style Guide . I realize that that's not always possible or practical, so some exceptions can be made in the interest of functionality. Utility - Contributions should expand or enhance Order in a way that aligns with the project's design philosophy of making things simpler and easier for the developer. Anything that does not do so will be rejected. Documentation - Any changes that add complex functionality should contain comments that explain why you're doing what you're doing. This is also part of the Roblox Luau Style Guide (rule #1), but is worth reiterating.","title":"Contributions"},{"location":"contributions/#want-to-make-a-contribution","text":"Order is a fully open-source project, and I would love to take community contributions that will make it even better! In the interest of quality control though, I've decided to set forth some rules that contributions must follow in order to be integrated into the project. If this all sounds good to you, make a pull request !","title":"Want to make a contribution?"},{"location":"contributions/#rules","text":"Style - Contributions should do their best to conform to the Roblox Luau Style Guide . I realize that that's not always possible or practical, so some exceptions can be made in the interest of functionality. Utility - Contributions should expand or enhance Order in a way that aligns with the project's design philosophy of making things simpler and easier for the developer. Anything that does not do so will be rejected. Documentation - Any changes that add complex functionality should contain comments that explain why you're doing what you're doing. This is also part of the Roblox Luau Style Guide (rule #1), but is worth reiterating.","title":"Rules"},{"location":"gettingstarted/","text":"Getting started To get started working with Order, you can use any of the options detailed below. Be sure to check out the API for details on how everything works! Cyclone Cyclone is an implementation of the Order framework that also comes packaged with some commonly used utilities that can speed up development quite a bit. It is the recommended way to get up and running with Order. Go here to get started. Rojo Clone the repo The repository for Order can be found here . A Rojo project file is included in the repository, so it's as simple as creating a new place file and serving it up! If you'd like to learn more about Rojo, see the official documentation . Roblox Get the package I highly recommend the professional environment that Rojo offers, but if you'd like, you can also get Order directly from the Roblox catalog here . Installation instructions are included with the package. Note that this package follows a different setup structure and has to be updated manually, so updates come a lot slower to this version and it may often be out of date.","title":"Getting started"},{"location":"gettingstarted/#getting-started","text":"To get started working with Order, you can use any of the options detailed below. Be sure to check out the API for details on how everything works!","title":"Getting started"},{"location":"gettingstarted/#cyclone","text":"Cyclone is an implementation of the Order framework that also comes packaged with some commonly used utilities that can speed up development quite a bit. It is the recommended way to get up and running with Order. Go here to get started.","title":"Cyclone"},{"location":"gettingstarted/#rojo","text":"","title":"Rojo"},{"location":"gettingstarted/#clone-the-repo","text":"The repository for Order can be found here . A Rojo project file is included in the repository, so it's as simple as creating a new place file and serving it up! If you'd like to learn more about Rojo, see the official documentation .","title":"Clone the repo"},{"location":"gettingstarted/#roblox","text":"","title":"Roblox"},{"location":"gettingstarted/#get-the-package","text":"I highly recommend the professional environment that Rojo offers, but if you'd like, you can also get Order directly from the Roblox catalog here . Installation instructions are included with the package. Note that this package follows a different setup structure and has to be updated manually, so updates come a lot slower to this version and it may often be out of date.","title":"Get the package"},{"location":"notes/","text":"Some special notes No bare code in modules with circular dependencies In order to support circular dependencies, it must be guaranteed that the module in question has no bare code that references a circular dependency . That is to say that any code that references the circular dependency must be contained within a function. If Order detects this bare code, you will be notified with a warning in the output and no operation will be processed on the module in question. Loading modules with non-unique names Modules can be specified through several different paths. If the name is unique, you can reference it simply through that. If two modules exist with the same name however, Order will warn you that it found two or more possible modules for your request, and will ask you to be more specific. You can use any level of the module paths it provides you with, as long as they're unique as well. Order does not index all potential file paths by default, so it is recommended to use the shortest unique paths possible in order to conserve memory usage. Printing module tables One of the complications with the method Order uses to support circular dependencies is that if you try to print out one of these module's tables, it would return a table address instead of an output-friendly table. In order to preserve as much functionality as possible, Order will list out table keys and values in a custom format when converting the table to a string.","title":"Special notes"},{"location":"notes/#some-special-notes","text":"","title":"Some special notes"},{"location":"notes/#no-bare-code-in-modules-with-circular-dependencies","text":"In order to support circular dependencies, it must be guaranteed that the module in question has no bare code that references a circular dependency . That is to say that any code that references the circular dependency must be contained within a function. If Order detects this bare code, you will be notified with a warning in the output and no operation will be processed on the module in question.","title":"No bare code in modules with circular dependencies"},{"location":"notes/#loading-modules-with-non-unique-names","text":"Modules can be specified through several different paths. If the name is unique, you can reference it simply through that. If two modules exist with the same name however, Order will warn you that it found two or more possible modules for your request, and will ask you to be more specific. You can use any level of the module paths it provides you with, as long as they're unique as well. Order does not index all potential file paths by default, so it is recommended to use the shortest unique paths possible in order to conserve memory usage.","title":"Loading modules with non-unique names"},{"location":"notes/#printing-module-tables","text":"One of the complications with the method Order uses to support circular dependencies is that if you try to print out one of these module's tables, it would return a table address instead of an output-friendly table. In order to preserve as much functionality as possible, Order will list out table keys and values in a custom format when converting the table to a string.","title":"Printing module tables"}]}