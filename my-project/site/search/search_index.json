{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A lightweight module loading framework for Roblox created by @ChiefWildin What's so special about Order? The purpose of Order is to simplify the way you structure your game projects. It combines the best features of the most popular frameworks, and adds a few of its own. Are there any unique features in Order? One of the main goals I wanted to achieve with Order was to remove barriers and enable the developer. Specifically I wanted to enable the ability to have modules with circular dependencies, as it is reasonable for libaries and tasks to need to interchangably use one another's public functions. I've achieved this through a bait-and-switch tactic, and Order is fully compatible with these kinds of modules. Is there anything else I need to know? Order is a relatively new framework, and I'm still actively developing it. As such, functionality and features can and will change at any time and I'm still ironing out all the kinks and bugs. If you have any suggestions or find any bugs yourself, feel free to reach out! I can be contacted on Discord at chiefwildin#0189","title":"Home"},{"location":"#_1","text":"A lightweight module loading framework for Roblox created by @ChiefWildin","title":""},{"location":"#whats-so-special-about-order","text":"The purpose of Order is to simplify the way you structure your game projects. It combines the best features of the most popular frameworks, and adds a few of its own.","title":"What's so special about Order?"},{"location":"#are-there-any-unique-features-in-order","text":"One of the main goals I wanted to achieve with Order was to remove barriers and enable the developer. Specifically I wanted to enable the ability to have modules with circular dependencies, as it is reasonable for libaries and tasks to need to interchangably use one another's public functions. I've achieved this through a bait-and-switch tactic, and Order is fully compatible with these kinds of modules.","title":"Are there any unique features in Order?"},{"location":"#is-there-anything-else-i-need-to-know","text":"Order is a relatively new framework, and I'm still actively developing it. As such, functionality and features can and will change at any time and I'm still ironing out all the kinks and bugs. If you have any suggestions or find any bugs yourself, feel free to reach out! I can be contacted on Discord at chiefwildin#0189","title":"Is there anything else I need to know?"},{"location":"api/","text":"API File structure Tasks Tasks are modules that have code intended for immediate execution at runtime. This code should be placed in a function called :Init() , which is called asynchronously and automatically. Tasks should be placed in the tasks folder of the appropriate context. Info Any module that is placed inside the tasks folder will be loaded by default, even if no :Init() function exists within it or if it isn't even a table. All other modules are loaded only by request. Priorities If you wish to give a task priority during the initialization phase, set a Priority key in the main module table to the priority level you would like (higher values load first, negative values load after default). Setting a priority is optional - if you don't set one, the task will be set to the lowest priority. Warning Tasks with priorities are still initialized asynchronously, so if the task yields during initialization there is no guarantee that it will finish before a lower priority task starts initializing. Tasks with the same priority are initialized in an arbitrary order. Example local NewTask = { Priority = 5 } function NewTask : Init () print ( \"We're running a task!\" ) end return NewTask Everything else All other modules can be placed in the provided lib folder or any other custom folders that you create. File paths There are five top-level directories by default: character - StarterPlayer.StarterCharacterScripts client - StarterPlayer.StarterPlayerScripts first - ReplicatedFirst server - ServerScriptService shared - ReplicatedStorage.Common Note first and character are not scanned for task modules. If you wish to do so, you may add custom support in the default client or server script. For Rojo users, further file path customization can be configured in the default.project.json file. Loading dependencies Order makes use of the shared global variable to load dependencies. In code, this takes the place of the usual require keyword. This function can take either a string of the module's name, a string of a partial or complete path to the module, or a direct object reference to a ModuleScript. Valid examples: local Tweentown = shared ( \"Tweentown\" ) local Tweentown = shared ( \"lib/Tweentown\" ) local Tweentown = shared ( game : GetService ( \"ReplicatedStorage\" ). Common . lib . Tweentown ) Warning When two or more modules exist with the same name or partial path, Order will warn you that it found multiple modules for your request, and will ask you to be more specific. You can use any level of the module paths it provides you with, as long as it is unique. As of v0.5.0, you can also now use the Order module in place of shared if you have other uses for that keyword, or want to avoid globals like the plague. For example: local require = require ( game : GetService ( \"ReplicatedStorage\" ). Common . Order ) Supporting modules from other frameworks If you would like to import a module from another framework that uses require to load dependencies, simply redirect require to shared : local require = shared Or, alternatively, you can redirect their require call to the main Order module: local require = require ( game : GetService ( \"ReplicatedStorage\" ). Common . Order )","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#file-structure","text":"","title":"File structure"},{"location":"api/#tasks","text":"Tasks are modules that have code intended for immediate execution at runtime. This code should be placed in a function called :Init() , which is called asynchronously and automatically. Tasks should be placed in the tasks folder of the appropriate context. Info Any module that is placed inside the tasks folder will be loaded by default, even if no :Init() function exists within it or if it isn't even a table. All other modules are loaded only by request.","title":"Tasks"},{"location":"api/#priorities","text":"If you wish to give a task priority during the initialization phase, set a Priority key in the main module table to the priority level you would like (higher values load first, negative values load after default). Setting a priority is optional - if you don't set one, the task will be set to the lowest priority. Warning Tasks with priorities are still initialized asynchronously, so if the task yields during initialization there is no guarantee that it will finish before a lower priority task starts initializing. Tasks with the same priority are initialized in an arbitrary order.","title":"Priorities"},{"location":"api/#example","text":"local NewTask = { Priority = 5 } function NewTask : Init () print ( \"We're running a task!\" ) end return NewTask","title":"Example"},{"location":"api/#everything-else","text":"All other modules can be placed in the provided lib folder or any other custom folders that you create.","title":"Everything else"},{"location":"api/#file-paths","text":"There are five top-level directories by default: character - StarterPlayer.StarterCharacterScripts client - StarterPlayer.StarterPlayerScripts first - ReplicatedFirst server - ServerScriptService shared - ReplicatedStorage.Common Note first and character are not scanned for task modules. If you wish to do so, you may add custom support in the default client or server script. For Rojo users, further file path customization can be configured in the default.project.json file.","title":"File paths"},{"location":"api/#loading-dependencies","text":"Order makes use of the shared global variable to load dependencies. In code, this takes the place of the usual require keyword. This function can take either a string of the module's name, a string of a partial or complete path to the module, or a direct object reference to a ModuleScript. Valid examples: local Tweentown = shared ( \"Tweentown\" ) local Tweentown = shared ( \"lib/Tweentown\" ) local Tweentown = shared ( game : GetService ( \"ReplicatedStorage\" ). Common . lib . Tweentown ) Warning When two or more modules exist with the same name or partial path, Order will warn you that it found multiple modules for your request, and will ask you to be more specific. You can use any level of the module paths it provides you with, as long as it is unique. As of v0.5.0, you can also now use the Order module in place of shared if you have other uses for that keyword, or want to avoid globals like the plague. For example: local require = require ( game : GetService ( \"ReplicatedStorage\" ). Common . Order )","title":"Loading dependencies"},{"location":"api/#supporting-modules-from-other-frameworks","text":"If you would like to import a module from another framework that uses require to load dependencies, simply redirect require to shared : local require = shared Or, alternatively, you can redirect their require call to the main Order module: local require = require ( game : GetService ( \"ReplicatedStorage\" ). Common . Order )","title":"Supporting modules from other frameworks"},{"location":"gettingstarted/","text":"Getting started Rojo Clone the repo The repository for Order can be found here . A Rojo project file is included in the repository, so it's as simple as loading up a new place file and serving it up! If you'd like to learn more about Rojo, see the official documentation . Roblox Get the package I highly recommend the professional environment that Rojo offers, but you can also get Order directly from the Roblox catalog here . Installation instructions are included with the package.","title":"Getting started"},{"location":"gettingstarted/#getting-started","text":"","title":"Getting started"},{"location":"gettingstarted/#rojo","text":"","title":"Rojo"},{"location":"gettingstarted/#clone-the-repo","text":"The repository for Order can be found here . A Rojo project file is included in the repository, so it's as simple as loading up a new place file and serving it up! If you'd like to learn more about Rojo, see the official documentation .","title":"Clone the repo"},{"location":"gettingstarted/#roblox","text":"","title":"Roblox"},{"location":"gettingstarted/#get-the-package","text":"I highly recommend the professional environment that Rojo offers, but you can also get Order directly from the Roblox catalog here . Installation instructions are included with the package.","title":"Get the package"},{"location":"included/","text":"Modules included with Order Tweentown Tweentown is an extension of TweenService that makes it easy to create, play, and clean up tweens in a simple one-shot call. It also expands TweenService functionality by allowing tweens on Models, NumberSequences, and ColorSequences. SpringCity SpringCity is the equivalent of Tweentown that uses springs instead of tweens. It comes preloaded with an expanded version of Quenty's Spring.lua module, optimized by TactBacon and modified by ChiefWildin to natively support more Roblox-specific types. Set Set is a module provided by Roblox that provides a class used to create sets. A set is a collection of objects or values that contains no duplicates and does not preserve order.","title":"Included modules"},{"location":"included/#modules-included-with-order","text":"","title":"Modules included with Order"},{"location":"included/#tweentown","text":"Tweentown is an extension of TweenService that makes it easy to create, play, and clean up tweens in a simple one-shot call. It also expands TweenService functionality by allowing tweens on Models, NumberSequences, and ColorSequences.","title":"Tweentown"},{"location":"included/#springcity","text":"SpringCity is the equivalent of Tweentown that uses springs instead of tweens. It comes preloaded with an expanded version of Quenty's Spring.lua module, optimized by TactBacon and modified by ChiefWildin to natively support more Roblox-specific types.","title":"SpringCity"},{"location":"included/#set","text":"Set is a module provided by Roblox that provides a class used to create sets. A set is a collection of objects or values that contains no duplicates and does not preserve order.","title":"Set"},{"location":"notes/","text":"Some special notes No bare code in modules with circular dependencies In order to support circular dependencies, it must be guaranteed that the module in question has no bare code that references a circular dependency . That is to say that any code that references the circular dependency must be contained within a function. If Order detects this bare code, you will be notified with a warning in the output and no operation will be processed on the module in question. Loading modules with non-unique names Modules can be specified through several different paths. If the name is unique, you can reference it simply through that. If two modules exist with the same name however, Order will warn you that it found two or more possible modules for your request, and will ask you to be more specific. You can use any level of the module paths it provides you with, as long as they're unique as well. Printing module tables One of the complications with the method Order uses to support circular dependencies is that if you try to print out one of these module's tables, it would return a table address instead of an output-friendly table. In order to preserve as much functionality as possible, Order will list out table keys and values in a custom format when converting the table to a string.","title":"Special notes"},{"location":"notes/#some-special-notes","text":"","title":"Some special notes"},{"location":"notes/#no-bare-code-in-modules-with-circular-dependencies","text":"In order to support circular dependencies, it must be guaranteed that the module in question has no bare code that references a circular dependency . That is to say that any code that references the circular dependency must be contained within a function. If Order detects this bare code, you will be notified with a warning in the output and no operation will be processed on the module in question.","title":"No bare code in modules with circular dependencies"},{"location":"notes/#loading-modules-with-non-unique-names","text":"Modules can be specified through several different paths. If the name is unique, you can reference it simply through that. If two modules exist with the same name however, Order will warn you that it found two or more possible modules for your request, and will ask you to be more specific. You can use any level of the module paths it provides you with, as long as they're unique as well.","title":"Loading modules with non-unique names"},{"location":"notes/#printing-module-tables","text":"One of the complications with the method Order uses to support circular dependencies is that if you try to print out one of these module's tables, it would return a table address instead of an output-friendly table. In order to preserve as much functionality as possible, Order will list out table keys and values in a custom format when converting the table to a string.","title":"Printing module tables"}]}