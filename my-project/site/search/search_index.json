{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A lightweight module-based framework for Roblox created by @ChiefWildin What's so special about Order? The core design principle in Order is to remove barriers and enable the developer . It combines the best features of current popular frameworks, and adds a few of its own. Are there any unique features in Order? There are! One of these unique features is the ability to have modules with circular dependencies. I added this because I consider it reasonable for libaries and tasks to need to interchangably use one another's public functions. This is achieved this through a sort of bait-and-switch tactic, and Order is compatible with these kinds of modules (see Special notes ). Is there anything else I need to know? Order is a relatively new framework, and I'm still actively developing it. As such, functionality and features can and will change at any time and I'm still ironing out all the kinks and bugs. If you have any suggestions or find any bugs yourself, feel free to reach out! Issues, discussions, and pull requests can be submitted to the project repo , or I can be contacted directly on Discord at chiefwildin#0189","title":"Home"},{"location":"#_1","text":"A lightweight module-based framework for Roblox created by @ChiefWildin","title":""},{"location":"#whats-so-special-about-order","text":"The core design principle in Order is to remove barriers and enable the developer . It combines the best features of current popular frameworks, and adds a few of its own.","title":"What's so special about Order?"},{"location":"#are-there-any-unique-features-in-order","text":"There are! One of these unique features is the ability to have modules with circular dependencies. I added this because I consider it reasonable for libaries and tasks to need to interchangably use one another's public functions. This is achieved this through a sort of bait-and-switch tactic, and Order is compatible with these kinds of modules (see Special notes ).","title":"Are there any unique features in Order?"},{"location":"#is-there-anything-else-i-need-to-know","text":"Order is a relatively new framework, and I'm still actively developing it. As such, functionality and features can and will change at any time and I'm still ironing out all the kinks and bugs. If you have any suggestions or find any bugs yourself, feel free to reach out! Issues, discussions, and pull requests can be submitted to the project repo , or I can be contacted directly on Discord at chiefwildin#0189","title":"Is there anything else I need to know?"},{"location":"api/","text":"API Settings The main framework module (found in src/shared/Order/init.lua ) has a few different settings that developers can tweak for their projects. DebugMode - When set to true this will make the loading process verbose so that you can iterate on the framework or tweak behavior. SilentMode - When set to true this will disable all regular output (version printing, notifications about when initialization has finished, etc.) This will not disable warnings. By default this is turned off during Studio development, and turned on for production. ForceSyncInit - When set to true , forces the task initialization process to be performed synchronously regardless of individual task settings. SlowInitWarnTime - The numbers of seconds that Order will wait before warning you that a task is taking too long to initialize. File structure Tasks Tasks are modules that have code intended for immediate execution at runtime. This code should be placed in a function called :Init() , which is called asynchronously and automatically. Tasks should be placed in the tasks folder of the appropriate context. Info Any module that is placed inside the tasks folder will be loaded by default, even if no :Init() function exists within it or if it isn't even a table. All other modules are loaded only by request. Priorities If you wish to give a task priority during the initialization phase, set a Priority key in the main module table to the priority level you would like (higher values load first, negative values load after default). Setting a priority is optional - if you don't set one, the task will be set to the lowest priority. Warning Tasks with priorities are still initialized asynchronously, so if the task yields during initialization there is no guarantee that it will finish before a lower priority task starts initializing. Tasks with the same priority are initialized in an arbitrary order. Synchronization By default, tasks are initialized asynchronously. This means that if any task yields during its :Init() function, the next task in the initialization queue will begin to execute while it is doing so. This behavior can be modified in two ways. The first is by setting Order.ForceSyncInit to true (see Settings ), which forces all tasks to load synchronously, meaning that any yielding task will hold up the initialization queue. The second is by setting a SyncInit key to true in the main module table, which will tell Order to load that particular task synchronously. These settings can be useful for forcing a certain init order, but can slow down that stage at the same time. Example local NewTask = { Priority = 5 , SyncInit = true , } function NewTask : Init () print ( \"We're running a task!\" ) end return NewTask Everything else All other modules can be placed in the provided lib folder, or any other custom folders that you create. File paths There are five top-level directories by default: character - StarterPlayer.StarterCharacterScripts client - StarterPlayer.StarterPlayerScripts first - ReplicatedFirst server - ServerScriptService shared - ReplicatedStorage.Common Note first and character are not scanned for task modules, as it is assumed that developers will simply use LocalScripts/Scripts instead. If you wish to add tasks there, you may add custom support at the end of the main framework module. For Rojo users, further file path customization can be configured in the default.project.json file. Loading dependencies Order makes use of the shared global variable to load dependencies. In code, this takes the place of the usual require keyword. This function can take either a string of the module's name, a string of a partial or complete path to the module, or a direct object reference to a ModuleScript. Valid examples: local Tweentown = shared ( \"Tweentown\" ) local Tweentown = shared ( \"lib/Tweentown\" ) local Tweentown = shared ( game : GetService ( \"ReplicatedStorage\" ). Common . lib . Tweentown ) Warning When two or more modules exist with the same name or partial path, Order will warn you that it found multiple modules for your request, and will ask you to be more specific. You can use any level of the module paths it provides you with, as long as it is unique. As of v0.5.0, you can also now use the Order module in place of shared if you have other uses for that keyword, or want to avoid globals like the plague. For example: local require = require ( game : GetService ( \"ReplicatedStorage\" ). Common . Order ) Supporting modules from other frameworks If you would like to import a module from another framework that uses require to load dependencies, simply redirect require to shared : local require = shared Or, alternatively, you can redirect their require call to the main Order module: local require = require ( game : GetService ( \"ReplicatedStorage\" ). Common . Order )","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#settings","text":"The main framework module (found in src/shared/Order/init.lua ) has a few different settings that developers can tweak for their projects. DebugMode - When set to true this will make the loading process verbose so that you can iterate on the framework or tweak behavior. SilentMode - When set to true this will disable all regular output (version printing, notifications about when initialization has finished, etc.) This will not disable warnings. By default this is turned off during Studio development, and turned on for production. ForceSyncInit - When set to true , forces the task initialization process to be performed synchronously regardless of individual task settings. SlowInitWarnTime - The numbers of seconds that Order will wait before warning you that a task is taking too long to initialize.","title":"Settings"},{"location":"api/#file-structure","text":"","title":"File structure"},{"location":"api/#tasks","text":"Tasks are modules that have code intended for immediate execution at runtime. This code should be placed in a function called :Init() , which is called asynchronously and automatically. Tasks should be placed in the tasks folder of the appropriate context. Info Any module that is placed inside the tasks folder will be loaded by default, even if no :Init() function exists within it or if it isn't even a table. All other modules are loaded only by request.","title":"Tasks"},{"location":"api/#priorities","text":"If you wish to give a task priority during the initialization phase, set a Priority key in the main module table to the priority level you would like (higher values load first, negative values load after default). Setting a priority is optional - if you don't set one, the task will be set to the lowest priority. Warning Tasks with priorities are still initialized asynchronously, so if the task yields during initialization there is no guarantee that it will finish before a lower priority task starts initializing. Tasks with the same priority are initialized in an arbitrary order.","title":"Priorities"},{"location":"api/#synchronization","text":"By default, tasks are initialized asynchronously. This means that if any task yields during its :Init() function, the next task in the initialization queue will begin to execute while it is doing so. This behavior can be modified in two ways. The first is by setting Order.ForceSyncInit to true (see Settings ), which forces all tasks to load synchronously, meaning that any yielding task will hold up the initialization queue. The second is by setting a SyncInit key to true in the main module table, which will tell Order to load that particular task synchronously. These settings can be useful for forcing a certain init order, but can slow down that stage at the same time.","title":"Synchronization"},{"location":"api/#example","text":"local NewTask = { Priority = 5 , SyncInit = true , } function NewTask : Init () print ( \"We're running a task!\" ) end return NewTask","title":"Example"},{"location":"api/#everything-else","text":"All other modules can be placed in the provided lib folder, or any other custom folders that you create.","title":"Everything else"},{"location":"api/#file-paths","text":"There are five top-level directories by default: character - StarterPlayer.StarterCharacterScripts client - StarterPlayer.StarterPlayerScripts first - ReplicatedFirst server - ServerScriptService shared - ReplicatedStorage.Common Note first and character are not scanned for task modules, as it is assumed that developers will simply use LocalScripts/Scripts instead. If you wish to add tasks there, you may add custom support at the end of the main framework module. For Rojo users, further file path customization can be configured in the default.project.json file.","title":"File paths"},{"location":"api/#loading-dependencies","text":"Order makes use of the shared global variable to load dependencies. In code, this takes the place of the usual require keyword. This function can take either a string of the module's name, a string of a partial or complete path to the module, or a direct object reference to a ModuleScript. Valid examples: local Tweentown = shared ( \"Tweentown\" ) local Tweentown = shared ( \"lib/Tweentown\" ) local Tweentown = shared ( game : GetService ( \"ReplicatedStorage\" ). Common . lib . Tweentown ) Warning When two or more modules exist with the same name or partial path, Order will warn you that it found multiple modules for your request, and will ask you to be more specific. You can use any level of the module paths it provides you with, as long as it is unique. As of v0.5.0, you can also now use the Order module in place of shared if you have other uses for that keyword, or want to avoid globals like the plague. For example: local require = require ( game : GetService ( \"ReplicatedStorage\" ). Common . Order )","title":"Loading dependencies"},{"location":"api/#supporting-modules-from-other-frameworks","text":"If you would like to import a module from another framework that uses require to load dependencies, simply redirect require to shared : local require = shared Or, alternatively, you can redirect their require call to the main Order module: local require = require ( game : GetService ( \"ReplicatedStorage\" ). Common . Order )","title":"Supporting modules from other frameworks"},{"location":"contributions/","text":"Want to make a contribution? Order is a fully open-source project, and I would love to take community contributions that will make it even better! In the interest of quality control though, I've decided to set forth some rules (see below) that contributions must follow in order to be integrated into the project. If this all sounds good to you, make a pull request! Rules Style - Contributions should do their best to conform to the Roblox Luau Style Guide . I realize that that's not always possible, so minor exceptions can be made in the interest of functionality. Utility - Contributions should expand or enhance Order in a way that aligns with the project's design philosophy of making things simpler and easier for the developer. Anything that does not do so will be rejected. Documentation - Any changes that add complex functionality should contain comments that explain why you're doing what you're doing. This is also part of the Roblox Luau Style Guide (rule #1), but is worth reiterating. Branches - I'm totally open to creating more branches with prepackaged sets of modules. If you have the rights to a useful set that you think could benefit the community, feel free to request an official branch for it.","title":"Contributions"},{"location":"contributions/#want-to-make-a-contribution","text":"Order is a fully open-source project, and I would love to take community contributions that will make it even better! In the interest of quality control though, I've decided to set forth some rules (see below) that contributions must follow in order to be integrated into the project. If this all sounds good to you, make a pull request!","title":"Want to make a contribution?"},{"location":"contributions/#rules","text":"Style - Contributions should do their best to conform to the Roblox Luau Style Guide . I realize that that's not always possible, so minor exceptions can be made in the interest of functionality. Utility - Contributions should expand or enhance Order in a way that aligns with the project's design philosophy of making things simpler and easier for the developer. Anything that does not do so will be rejected. Documentation - Any changes that add complex functionality should contain comments that explain why you're doing what you're doing. This is also part of the Roblox Luau Style Guide (rule #1), but is worth reiterating. Branches - I'm totally open to creating more branches with prepackaged sets of modules. If you have the rights to a useful set that you think could benefit the community, feel free to request an official branch for it.","title":"Rules"},{"location":"gettingstarted/","text":"Getting started To get started working with Order, you can use either of the two methods detailed below. Be sure to check out the API for details on how everything works! Rojo Clone the repo The repository for Order can be found here . A Rojo project file is included in the repository, so it's as simple as creating a new place file and serving it up! If you'd like to learn more about Rojo, see the official documentation . Roblox Get the package I highly recommend the professional environment that Rojo offers, but if you'd like, you can also get Order directly from the Roblox catalog here . Installation instructions are included with the package.","title":"Getting started"},{"location":"gettingstarted/#getting-started","text":"To get started working with Order, you can use either of the two methods detailed below. Be sure to check out the API for details on how everything works!","title":"Getting started"},{"location":"gettingstarted/#rojo","text":"","title":"Rojo"},{"location":"gettingstarted/#clone-the-repo","text":"The repository for Order can be found here . A Rojo project file is included in the repository, so it's as simple as creating a new place file and serving it up! If you'd like to learn more about Rojo, see the official documentation .","title":"Clone the repo"},{"location":"gettingstarted/#roblox","text":"","title":"Roblox"},{"location":"gettingstarted/#get-the-package","text":"I highly recommend the professional environment that Rojo offers, but if you'd like, you can also get Order directly from the Roblox catalog here . Installation instructions are included with the package.","title":"Get the package"},{"location":"included/","text":"Modules included with Order Order is separated into branches with different sets of prepackaged modules. Master This is the main branch that contains no extra modules. It just the vanilla, barebones framework. Loaded This branch contains my personally created modules, plus some provided by Roblox. It includes some very useful utilities such as AnimNation for easy one-shot animation calls, CreateTagGroup for easily tracking sets of tagged objects, Insanity for protecting function calls that may fail sometimes, and more. Other branches I have plans to make more branches soon with different flavors of Order, including one for Nevermore V2 modules. Stay tuned.","title":"Branches / Modules"},{"location":"included/#modules-included-with-order","text":"Order is separated into branches with different sets of prepackaged modules.","title":"Modules included with Order"},{"location":"included/#master","text":"This is the main branch that contains no extra modules. It just the vanilla, barebones framework.","title":"Master"},{"location":"included/#loaded","text":"This branch contains my personally created modules, plus some provided by Roblox. It includes some very useful utilities such as AnimNation for easy one-shot animation calls, CreateTagGroup for easily tracking sets of tagged objects, Insanity for protecting function calls that may fail sometimes, and more.","title":"Loaded"},{"location":"included/#other-branches","text":"I have plans to make more branches soon with different flavors of Order, including one for Nevermore V2 modules. Stay tuned.","title":"Other branches"},{"location":"notes/","text":"Some special notes No bare code in modules with circular dependencies In order to support circular dependencies, it must be guaranteed that the module in question has no bare code that references a circular dependency . That is to say that any code that references the circular dependency must be contained within a function. If Order detects this bare code, you will be notified with a warning in the output and no operation will be processed on the module in question. Loading modules with non-unique names Modules can be specified through several different paths. If the name is unique, you can reference it simply through that. If two modules exist with the same name however, Order will warn you that it found two or more possible modules for your request, and will ask you to be more specific. You can use any level of the module paths it provides you with, as long as they're unique as well. Order does not index all potential file paths by default, so it is recommended to use the shortest unique paths possible in order to conserve memory usage. Printing module tables One of the complications with the method Order uses to support circular dependencies is that if you try to print out one of these module's tables, it would return a table address instead of an output-friendly table. In order to preserve as much functionality as possible, Order will list out table keys and values in a custom format when converting the table to a string.","title":"Special notes"},{"location":"notes/#some-special-notes","text":"","title":"Some special notes"},{"location":"notes/#no-bare-code-in-modules-with-circular-dependencies","text":"In order to support circular dependencies, it must be guaranteed that the module in question has no bare code that references a circular dependency . That is to say that any code that references the circular dependency must be contained within a function. If Order detects this bare code, you will be notified with a warning in the output and no operation will be processed on the module in question.","title":"No bare code in modules with circular dependencies"},{"location":"notes/#loading-modules-with-non-unique-names","text":"Modules can be specified through several different paths. If the name is unique, you can reference it simply through that. If two modules exist with the same name however, Order will warn you that it found two or more possible modules for your request, and will ask you to be more specific. You can use any level of the module paths it provides you with, as long as they're unique as well. Order does not index all potential file paths by default, so it is recommended to use the shortest unique paths possible in order to conserve memory usage.","title":"Loading modules with non-unique names"},{"location":"notes/#printing-module-tables","text":"One of the complications with the method Order uses to support circular dependencies is that if you try to print out one of these module's tables, it would return a table address instead of an output-friendly table. In order to preserve as much functionality as possible, Order will list out table keys and values in a custom format when converting the table to a string.","title":"Printing module tables"}]}